import java.io.*;
import java.util.Stack;


public class CalculatorTest
{
	public static void main(String args[])
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

		while (true)
		{
			try
			{
				String input = br.readLine();
				if (input.compareTo("q") == 0)
					break;

				command(input);
			}
			catch (Exception e)
			{
				System.out.println("입력이 잘못되었습니다. 오류 : " + e.toString());
			}
		}
	}

	private static void command(String input)
	{		
		String tmp = preProcess(input);
		String post = parsing(tmp);
		System.out.println(post);
		long res = evaluate(post);
		System.out.println(res);
		
	}
	
	
	
	private static int op_prec(char op){
		// 연산자의 우선순위를 반환하는 메소드. unary - 은 미리 ~ 로 변환되었다고 가정. 
		switch(op){
		case '^' :
			return 4;
		case '~' :
			return 3;
		case '*' :
		case '/' :
		case '%' :
			return 2;
		case '+' :
		case '-' :
			return 1;
		default :
			return 0;
		}
	}
	
	
	
	public static boolean isNumber(char a){
		// 숫자일 경우 true 반환
		return (a>='0' && a<='9');
	}
	
	public static boolean isOperator(char a){
		// 연산자일 경우 true 반환
		return (a=='^' || a=='~' || a=='*' || a=='/' || a=='%' || a=='+' || a=='-');
	}
	
	
	
	public static String preProcess(String input){
		 
		// 공백을 삭제한다.
		input = input.replaceAll(" ", ""); 
		StringBuffer sb = new StringBuffer(input);
		
		// '-' 이 unary인지 binary인지 판단한 후, unary일 경우 '~' 로 변환한다
		// '-' 이 숫자나 ')' 뒤에 나올 경우 binary, 그 이외의 경우는 unary로 판단 가능.
		if(sb.charAt(0) == '-'){
			sb.setCharAt(0, '~');
		}
		
		for(int i=1;i<sb.length();i++){
			if(sb.charAt(i) == '-' && !(sb.charAt(i-1) == ')' || isNumber(sb.charAt(i-1)))){
				sb.setCharAt(i, '~');
			}
		}	
		return sb.toString();
	}
	
	
	
	
	public static String parsing(String input){
		// infix -> postfix
		// 예외 처리 전혀 되어있지 않음... !!
		// 다양한 경우의 예외가 존재할 것. 대표적인 예시는 책에 나와있음. 
		
		StringBuffer result = new StringBuffer();
		StringBuffer tmp_number = new StringBuffer();
		Stack<Character> stack = new Stack<Character>();
		
		int i = 0;
		int size = input.length();
		
		while(i < size){
			
			char tmp = input.charAt(i);
			
			if(isNumber(tmp)){
				// (1) 숫자일 경우 숫자가 끝날 때 까지 입력받아서 한꺼번에 더한다 
				
				while(i< size  && isNumber(input.charAt(i))){
					tmp_number.append(input.charAt(i));
					i++;
				}
				result.append(tmp_number.toString());
				result.append(" ");
				tmp_number = new StringBuffer(); //초기화 
				continue;//다시 처음으로 
				
			}else if(tmp=='('){ // (2) 여는 괄호일 경우 괄호를 스택에 집어넣고 진행  
				stack.push(tmp);
				
			}else if(tmp==')'){ // (3) 닫는 괄호일 경우 여는 괄호가 나올 때까지 pop
				char b_tmp = stack.pop();
				while(b_tmp !='('){ 
					result.append(b_tmp);
					result.append(" ");
					b_tmp = stack.pop();
				}
				
			}else if(isOperator(tmp)){// 연산자일 경우 
				
				if(tmp == '^' || tmp == '~'){
					// right-associative
					while( !stack.isEmpty() && stack.peek()!='(' && op_prec(stack.peek()) > op_prec(tmp)){ //stack이 비어있지 않고, 괄호를 만나지 않았으며, 우선순위가 높다면 (높은 우선순위를 만나기 전까지)
						result.append(stack.pop());
						result.append(" ");
					}
					stack.push(tmp);
				}else{ 
					// left-associative
					while( !stack.isEmpty() && stack.peek()!='(' && op_prec(stack.peek()) >= op_prec(tmp)){ //stack이 비어있지 않고, 괄호를 만나지 않았으며, 우선순위가 같거나 높다면 (높은 우선순위를 만나기 전까지)
						result.append(stack.pop());
						result.append(" ");
					}
					stack.push(tmp);	
				}
			}else{// wrong input
				
				
			}
			i++;
		}
		
		
		while(!stack.isEmpty()){
			result.append(stack.pop());
			result.append(" ");
		}
		
		return result.toString();	
	}
	
	
	
	
	public static long evaluate(String input){
		// postfix 계산 
		
		Stack<Long> stack = new Stack<Long>();
		StringBuffer tmp_number = new StringBuffer();
		
		int sum = 0;

		int i = 0;
		int size = input.length();
		
		while(i < size){
			
			char tmp = input.charAt(i);
			
			if(isNumber(tmp)){//숫자일 경우
				while(i < size  && isNumber(input.charAt(i))){
					tmp_number.append(input.charAt(i));
					i++;
				}
				//숫자가 아닌 문자를 만나면 그동안 입력받은 숫자를 스택에 push
				stack.push(Long.parseLong(tmp_number.toString()));
				tmp_number = new StringBuffer(); //초기화 
				continue;//다시 처음으로 
				
			}else if(isOperator(tmp)){//operator일 경우. unary('~')일 경우 따로 처리해야 한다. 
				if(tmp == '~'){
					long k = stack.pop();
					stack.push(-k);//가장 상위의 스택의 부호 변경 
					
				}else{
					long first = stack.pop();
					long second = stack.pop();
					
					switch(tmp){
					case '^':
						stack.push((long)Math.pow(second, first));
						break;
					case '*': 
						stack.push(second*first);
						break;
					case '/': 
						stack.push(second/first);//divide by zero?
						break;
					case '%': 
						stack.push(second%first);
						break;
					case '+': 
						stack.push(second+first);
						break;
					case '-': 
						stack.push(second-first);
						break;
					default:
						//wrong input
					}	
				}
			}else if(tmp == ' '){
				//공백 : do nothing	
			}else{
				//wrong input
			}
			i++;
		}
		
		return stack.pop();
	}
	
}
