import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
 
 
public class BigInteger
{
    public static final String QUIT_COMMAND = "quit";
    public static final String MSG_INVALID_INPUT = "입력이 잘못되었습니다.";
    public static final int MAX_NUM = 200;
 
    // implement this
    // 정규식 사용해서 공백 제거, 부호, 연산자, 숫자 분리 
    public static final Pattern EXPRESSION_PATTERN = Pattern.compile("\\s*([\\+\\-\\*]?)\\s*([0-9]*)\\s*([\\+\\-\\*]?)\\s*([\\+\\-\\*]?)\\s*([0-9]*)\\s*");
 
    public int[] number;
    public int sign; //1 to +, 0 to -
    
    
    
    
    
    public BigInteger(int i)
    {
    }
    
    
    
 
    public BigInteger(int[] num1)
    {
    	//배열 복사 
    	this.number = new int[num1.length];
    	System.arraycopy(num1, 0, this.number, 0, num1.length);
    }
    
    
    
 
    public BigInteger(String s)
    {
    	// String-> int[] ex. "123" -> [3,2,1]
    	this.number = new int[s.length()];
    	for(int i=0;i<s.length();i++){
    		this.number[i] = s.charAt(s.length()-i-1)-'0';
    	}
    }
    
    
    
 
    public BigInteger add(BigInteger big)
    {
    	//두 정수 중에 큰 정수의 자릿수 +1 배열 할당 
    	//넘어올 때부터 자릿수는 this >= big 가 보장되는 것을 전제로 함. (모두 양수)
    	int size_big = this.number.length;
    	int size_small = big.number.length;
    	
    	//
    	int[] result_arr = new int[101];
    	
    	int carry = 0;
    	int i = 0;
    	// carry = 0 으로 시작  
    	for(i=0; i<size_small ;i++){
    		result_arr[i] = (this.number[i] + big.number[i] + carry) % 10;
    		carry = (this.number[i] + big.number[i] + carry) / 10;
    	}
    	// 나머지 처리 
    	result_arr[i] += carry;
    	for(; i<size_big ; i++){
    		result_arr[i] += this.number[i];
    	}
    	return new BigInteger(result_arr);
    }
    
    
    
    
 
    public BigInteger subtract(BigInteger big)
    {
    	//carry 처리를 제외하고는 기본적으로 add와 동일함
    	//역시 넘어올 때부터 자릿수는 this >= big 가 보장되는 것을 전제로 함. (모두 양수)
    	//또한 뺄셈 처리의 경우는 자릿수 말고도 숫자 자체가 this>=big이어야 함! (따로 처리 필요)
    	int size_big = this.number.length;
    	int size_small = big.number.length;
    	
    	int[] result_arr = new int[101];
    	
    	int carry = 0;
    	int i = 0;
    	
    	for(i=0; i<size_small ;i++){
    		
    		if(this.number[i] < (big.number[i]+carry)){
    			result_arr[i] = (10 + this.number[i] - big.number[i] - carry);
    			carry = 1;
    		}else{
    			result_arr[i] = (this.number[i] - big.number[i] - carry);
    			carry = 0;
    		}
    	}
    	// 나머지 처리 
    	result_arr[i] -= carry;
    	for(; i<size_big ; i++){
    		result_arr[i] += this.number[i];
    	}
    	return new BigInteger(result_arr);
    }
    
    
    
    
    
 
    public BigInteger multiply(BigInteger big)
    {
    	//일단 제일 간단하게 n^2 이중루프로 구현함. input 자체가 커봤자 100이기 때문에 카라추바 divide&conquer 사용하지 않음. 
    	//worst case ~ 100^100
    	//덧셈으로 구현하는 방법도 존재. (하지만 최악의 경우 shifting을 무시한다고 해도 1100*덧셈으로 더 비효율적 - 덧셈 자체가 O(n))
    	
    	int size_t = this.number.length;
    	int size_b = big.number.length;
    	
    	//자리수 계산이 유동적이므로 그냥 MAX로 설정해주자. 어차피 남는 건 toString method에서 처리 가능.
    	int[] result_arr = new int[201];
    	
    	int i = 0, j = 0;
    	
 
    	for(i=0 ; i<size_b ; i++){
    		int carry = 0;
    		for(j=0 ; j<size_t ; j++){
    			int tmp = result_arr[i+j] + (this.number[j] * big.number[i]) + carry;
    			result_arr[i+j] = tmp%10;
    			carry = tmp/10;
    		}
    		result_arr[i+j] += carry;
    	}
    	
    	return new BigInteger(result_arr);
    }
    
    
    
 
    @Override
    public String toString()
    {
    	StringBuffer sb = new StringBuffer();
    	
    	
    	
    	
    	
    	int i = this.number.length-1; // last index
    	
    	// 배열 첫 부분에 0있으면 지워줌
    	// 단, 모든 배열이 0일 가능성(정수0) 고려해야 함.
    	while(this.number[i] == 0 ){
    		i--;
    	}
    	
    	if(i==-1){
    		sb.append(0);
    	}
    	
    	for(; i>=0 ; i--){
    		sb.append(this.number[i]);
    	}
    	return sb.toString();
    }
    
    public static int my_compareTo(String a, String b){
    	if(a.length() > b.length()){
    		return 1;
    	}else if(a.length() < b.length()){
    		return -1;
    	}else{//size same
    		return a.compareTo(b);
    	}
    }
    
    
    
 
    static BigInteger evaluate(String input) throws IllegalArgumentException
    {
    	
    	//둘 중에 더 큰 수를 앞으로 빼줘야 함!! 여기서 처리하는 게 깔끔할 듯.
    	//sign_1 과 sign_2는 Null일 수 있으므로 따로 처리해줬음. 
    	Matcher m = EXPRESSION_PATTERN.matcher(input);
    	m.matches();
    	
    	String sign_1 = m.group(1);
    	String num_1 = m.group(2);
    	char operator = m.group(3).charAt(0);
    	String sign_2 = m.group(4);
    	String num_2 = m.group(5);
    	/*
    	System.out.println(sign_1);
    	System.out.println(num_1);
    	System.out.println(sign_2);

    	
    	
    	if(sign_1 == null){
    		sign_1 = "+";
    	}
    	
    	if(sign_2 == null){
    		sign_2 = "+";
    	}
    	
    	System.out.println(sign_1);
    	System.out.println(sign_2);
    	
    	
    	//대소 비교. num, sign을 동시에 저장해서 식별 가능하게 한다 
    	int tmp = my_compareTo(num_1, num_2);
    	String big_num, small_num;
    	String big_sign, small_sign;
    	
    	if(tmp>0){//num_1 > num_2
    		big_num = num_1;
    		big_sign = sign_1;
    		small_num = num_2;
    		small_sign = sign_2;
    	}else{//num_2 > num_1 || num_1 == num_2
    		big_num = num_2;
    		big_sign = sign_2;
    		small_num = num_1;
    		small_sign = sign_1;
    	}
    	
    	BigInteger num1 = new BigInteger(big_num);
    	BigInteger num2 = new BigInteger(small_num);
    	
    	switch(operator){
    	case '+':
    		if(big_sign.equals("+") && small_sign.equals("+")){
    			return num1.add(num2);
    		}
    		
    		break;
    	case '-':
    		
    		break;
    	
    	case '*':
    		
    		break;
    		
    	default : 
    		throw new IllegalArgumentException("Wrong Operator");
    	}*/
    	
    	return new BigInteger("0");
    }
 
    //test
    /*
    public static void main(String[] args){
    	
    	String tmp = "    +     1312311   +   +    442141   ";
    	Matcher m = EXPRESSION_PATTERN.matcher(tmp);
    	m.matches();
    	
    	System.out.println(m.group(0));
    	System.out.println(m.group(1));
    	System.out.println(m.group(2));
    	System.out.println(m.group(3));
    	System.out.println(m.group(4));
    	System.out.println(m.group(5));
    	
    	
    }*/
 
    
    
    
    
    
     
    public static void main(String[] args) throws Exception
    {
        try (InputStreamReader isr = new InputStreamReader(System.in))
        {
            try (BufferedReader reader = new BufferedReader(isr))
            {
                boolean done = false;
                while (!done)
                {
                    String input = reader.readLine();
 
                    try
                    {
                        done = processInput(input);
                    }
                    catch (IllegalArgumentException e)
                    {
                        System.err.println(MSG_INVALID_INPUT);
                    }
                }
            }
        }
    }
 
    static boolean processInput(String input) throws IllegalArgumentException
    {
        boolean quit = isQuitCmd(input);
 
        if (quit)
        {
            return true;
        }
        else
        {
            BigInteger result = evaluate(input);
            System.out.println(result.toString());
 
            return false;
        }
    }
 
    static boolean isQuitCmd(String input)
    {
        return input.equalsIgnoreCase(QUIT_COMMAND);
    }
}

