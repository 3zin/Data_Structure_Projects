import java.io.*;
import java.util.Stack;

/*
class My_node{
	
	char item;
	My_node next;
	
	public My_node(char item){
		this.item = item;
		this.next = null;
	}
	
	public My_node(char item, My_node next){
		this.item = item;
		this.next = next;
	}
	
}

class My_Stack{
	
	private My_node top;
	
	public My_Stack(){
		top = null;
	}
	
	public boolean isEmpty(){
		return top == null;
	}
	
	public void push(char item){
		top = new My_node(item, top);
	}
	
	public char pop() throws Exception{
		if(!this.isEmpty()){
			My_node tmp = top.next;
			top = top.next;
			return tmp.item;
		}else{
			throw new Exception("empty");
		}
	}
}*/



public class CalculatorTest
{
	public static void main(String args[])
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

		while (true)
		{
			try
			{
				String input = br.readLine();
				if (input.compareTo("q") == 0)
					break;

				command(input);
			}
			catch (Exception e)
			{
				System.out.println("입력이 잘못되었습니다. 오류 : " + e.toString());
			}
		}
	}

	private static void command(String input)
	{		
		String tmp = preProcess(input);
		System.out.println(parsing(tmp));
		
	}
	
	
	
	private static int op_prec(char op){
		// 연산자의 우선순위를 반환하는 메소드. unary - 은 미리 ~ 로 변환되었다고 가정. 
		switch(op){
		case '^' :
			return 4;
		case '~' :
			return 3;
		case '*' :
		case '/' :
		case '%' :
			return 2;
		case '+' :
		case '-' :
			return 1;
		default :
			return 0;
		}
	}
	
	
	
	public static boolean isNumber(char a){
		// 숫자일 경우 true 반환
		return (a>='0' && a<='9');
	}
	
	public static boolean isOperator(char a){
		// 연산자일 경우 true 반환
		return (a=='^' || a=='~' || a=='*' || a=='/' || a=='%' || a=='+' || a=='-');
	}
	
	
	
	public static String preProcess(String input){
		 
		// 공백을 삭제한다.
		input = input.replaceAll(" ", ""); 
		StringBuffer sb = new StringBuffer(input);
		
		// '-' 이 unary인지 binary인지 판단한 후, unary일 경우 '~' 로 변환한다
		// '-' 이 숫자나 ')' 뒤에 나올 경우 binary, 그 이외의 경우는 unary로 판단 가능.
		if(sb.charAt(0) == '-'){
			sb.setCharAt(0, '~');
		}
		
		for(int i=1;i<sb.length();i++){
			if(sb.charAt(i) == '-' && !(sb.charAt(i-1) == ')' || isNumber(sb.charAt(i-1)))){
				sb.setCharAt(i, '~');
			}
		}	
		return sb.toString();
	}
	
	
	
	
	public static String parsing(String input){
		
		
		StringBuffer result = new StringBuffer();
		StringBuffer tmp_number = new StringBuffer();
		Stack<Character> stack = new Stack<Character>();
		
		int i = 0;
		
		int size = input.length();
		
		while(i < size){
			
			char tmp = input.charAt(i);
			//System.out.println(tmp);
			
			if(isNumber(tmp)){// (1) 숫자일 경우 숫자가 끝날 때 까지 입력받아서 한꺼번에 더한다 
				
				while(i!= size  && isNumber(input.charAt(i))){
					tmp_number.append(input.charAt(i));
					i++;
				}
				result.append(tmp_number.toString());
				result.append(" ");
				tmp_number = new StringBuffer(); //초기화 
				continue;//다시 처음으로 
				
			}else if(tmp=='('){// (2) 괄호일 경우 
				stack.push(tmp);//집어넣는다
				
			}else if(tmp==')'){ // '(' 가 나올때까지 pop
				char b_tmp = stack.pop();
				while(b_tmp !='('){ 
					result.append(b_tmp);
					result.append(" ");
					b_tmp = stack.pop();
				}
				
			}else if(isOperator(tmp)){// 연산자일 경우 
				
				while( !stack.isEmpty() && stack.peek()!='(' && op_prec(stack.peek()) >= op_prec(tmp)){ //stack이 비어있지 않고, 괄호를 만나지 않았으며, 우선순위가 같거나 높다면 (높은 우선순위를 만나기 전까지)
					result.append(stack.pop());
					result.append(" ");
				}
				stack.push(tmp);
			}
			i++;
		}
		
		
		while(!stack.isEmpty()){
			result.append(stack.pop());
			result.append(" ");
		}
		
		return result.toString();
		
	}
	
	public static void evaluate(String input){
		
	}
	
}
